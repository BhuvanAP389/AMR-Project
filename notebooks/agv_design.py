# -*- coding: utf-8 -*-
"""AGV_design.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aqV_jbEseKEICeqSU2wLNddlW9WKl8mC
"""

import copy
import pandas as pd
import numpy as np
import seaborn as sns
import warnings
import plotly.express as px
from itertools import product
from scipy.integrate import simps
import matplotlib.pyplot as plt
from sympy import symbols, Eq, solve, sqrt

from google.colab import drive
drive.mount('/content/drive')



# Parameters of the staircase
h = 140
l = 340
hp = 17
lp = 13

plt.figure(figsize=(20, 10))
plt.plot([l, 660], [0, 0], color='black', linewidth=2, label="ground")
plt.plot([l, l], [0, h-hp], color='black', linewidth=2, label="height")
plt.plot([l, l+lp], [h-hp, h-hp], color='black', linewidth=2, label="width of the protruding part")
plt.plot([l+lp, l+lp], [h-hp, h], color='black', linewidth=2, label="width of the protruding part")
plt.plot([0, l+lp], [h, h], color='black', linewidth=2, label="width")
plt.xlim(0, 660)
plt.ylim(-1, 150)
plt.gca().invert_xaxis()

plt.annotate('', xy=(0, h-hp), xytext=(l, h-hp), arrowprops=dict(arrowstyle='<->', color='red', linewidth=2))
plt.annotate(f'Length = {l} mm', xy=(l/2-10, 118), xytext=(l/2, 118),
             fontsize=12, color='blue')

plt.annotate('', xy=(l+18, 0), xytext=(l+18, h), arrowprops=dict(arrowstyle='<->', color='red', linewidth=2))
plt.annotate(f'Height = {h} mm', xy=(l+28, h/2-5), xytext=(l+28, h/2),
             fontsize=12, color='blue', rotation=90)

plt.annotate('', xy=(l+lp/2+2, 122), xytext=(250, 104), arrowprops=dict(arrowstyle='->', color='red', linewidth=2))
plt.annotate(f'Protruding part width = {lp} mm', xy=(300, 100), xytext=(310, 100),
             fontsize=12, color='blue')

plt.annotate('', xy=(l + lp, h-hp + hp/2), xytext=(l + lp - 75, h-hp + hp/2), arrowprops=dict(arrowstyle='->', color='red', linewidth=2))
plt.annotate(f'Protruding part height = {hp} mm', xy=(l + lp + 5, h-hp + hp/2), xytext=(l + lp - 75, h-hp + hp/2-1),
             fontsize=12, color='blue')

plt.annotate('', xy=(l + lp, h+2), xytext=(0, h+2), arrowprops=dict(arrowstyle='<->', color='red', linewidth=2))
plt.annotate(f'Overall width = {l+lp} mm', xy=(l + lp/2, h + 5), xytext=(l/2 + lp/2, h+4),
             fontsize=12, color='blue')

plt.grid()
plt.show()

"""### Main dataframe generation code"""

columns = [
    'l1', 'l2', 'l3', 'l4', 'l5', 'l6', 'l7',
    'r1', 'r2', 'r3', 'Y1', 'Y2', 'a20', 'a2',
    'a30', 'a3', 'tb', 'bx', 'by', 'ADC',
    'DataFrame', 'A_C', 'Max height', 'S/N ratio'
]

def create_df(permutations, names):

  main_dff = pd.DataFrame(columns=columns)
  for i, perm in enumerate(permutations):
      row_data = {name: value for name, value in zip(names, perm)}
      row_data.update({
          'ADC': False,
          'DataFrame': {},
          'A_C': False})

      main_dff.loc[len(main_dff)] = row_data

  main_dff['ADC'] = main_dff['ADC'].astype(bool)
  main_dff['A_C'] = main_dff['A_C'].astype(bool)
  main_dff['DataFrame'] = main_dff['DataFrame'].astype(object)

  return main_dff

l1 = [80, 85, 90]
l2 = [80, 85, 90]
l3 = [190, 195, 200]
l4 = [150, 155, 145]
l6 = [60, 65, 70]
r1 = [55, 60, 65]
r2 = [55, 60, 65]
r3 = [55, 60, 65]

permutations = list(product(l1, l2, l3, l4, l6, r1, r2, r3))

columns = [
    'l1', 'l2', 'l3', 'l4', 'l5', 'l6', 'l7',
    'r1', 'r2', 'r3', 'Y1', 'Y2', 'a20', 'a2',
    'a30', 'a3', 'tb', 'bx', 'by', 'ADC',
    'DataFrame', 'A_C', 'Max height', 'S/N ratio'
]

names = ['l1', 'l2', 'l3', 'l4', 'l6', 'r1', 'r2', 'r3']

main_df = create_df(permutations, names)
print(f"DataFrame shape: {main_df.shape}")
print("\nColumn types:")
print(main_df.dtypes)

main_df

"""### Importing main_df"""

main_df = pd.read_csv('/content/output (3).csv')

print(f"DataFrame shape: {main_df.shape}")
print("\nColumn types:")
print(main_df.dtypes)

main_df['l5'] = 50
main_df

# Define the constraints functions
def constraints_function(data):
    rows_to_drop = []

    for i in range(data.shape[0]):
        l1 = data.loc[i, 'l1']
        l2 = data.loc[i, 'l2']
        l3 = data.loc[i, 'l3']
        l4 = data.loc[i, 'l4']
        l5 = data.loc[i, 'l5']

        r1 = data.loc[i, 'r1']
        r2 = data.loc[i, 'r2']
        r3 = data.loc[i, 'r3']

        constraints = [
            l1 + l2 > l4,
            l1 + l4 > l2,
            l2 + l4 > l1,
            r1 + r2 < l4,
            l3 - r3 > l2 + r2,
            l1 > r1,
            l2 > r2,
            l5 + 2 * r2 > 12
        ]

        if not all(constraints):
            rows_to_drop.append(i)

    data.drop(index=rows_to_drop, inplace=True)

    return data

def line_equation(point1, point2):
    x1, y1 = point1
    x2, y2 = point2

    if x2 == x1:
        raise ValueError("The points have the same x-coordinate, the line is vertical.")

    m = (y2 - y1) / (x2 - x1)
    c = y1 - m * x1
    return m, c

def distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    return round(np.sqrt((x2 - x1)**2 + (y2 - y1)**2), 2)

def arc(x1, y1, x2, y2, xc, yc, num):
  point1 = np.array([x1, y1])
  point2 = np.array([x2, y2])
  center = np.array([xc, yc])
  radius = np.linalg.norm(point1 - center)
  angle1 = np.arctan2(point1[1] - center[1], point1[0] - center[0])
  angle2 = np.arctan2(point2[1] - center[1], point2[0] - center[0])

  if angle2 < angle1:
      angle2 += 2 * np.pi
  angles = np.linspace(angle1, angle2, num=num)

  x_points = np.array(center[0] + radius * np.cos(angles))
  y_points = np.array(center[1] + radius * np.sin(angles))

  return x_points, y_points

def slope(x1, y1, x2, y2):
  t = np.arctan(np.abs(y2-y1)/np.abs(x2-x1))
  if((x2-x1)!=0):
    t = t if (y2-y1)/(x2-x1)>=0 else np.pi - t
  else:
    t = np.pi/2
  return t

def coordinate_of_the_third_point(x1, y1, x2, y2, len, alp):
  th = slope(x1, y1, x2, y2)
  x = round(x2 + len*np.cos(alp + th), 2) if np.degrees(th+alp)>90 else round(x2 - len*np.cos(alp + th), 2)
  y = round(y2 - len*np.sin(alp + th), 2) if np.degrees(th+alp)>180 else round(y2 + len*np.sin(alp + th), 2)
  return x, y

def find_third_point_sympy(x1, y1, x2, y2, l1, l2, l3):
  x3, y3 = symbols('x3 y3')
  eq1 = Eq(sqrt((x3 - x1)**2 + (y3 - y1)**2), l1)
  eq2 = Eq(sqrt((x3 - x2)**2 + (y3 - y2)**2), l3)
  solutions = solve((eq1, eq2), (x3, y3))
  return solutions

def second_wheel_circle1(x1, y1, l4, r2):
  X = (l+lp-x1)
  Y = (h-hp-y1)
  z = (l4**2 - (X**2 + Y**2 + r2**2))/(2*r2)
  beta = np.arcsin(X/np.sqrt(X**2 + Y**2)) - np.arcsin(z/np.sqrt(X**2 + Y**2))
  return beta

def second_wheel_circle2(x1, y1, l4, r2):
  X = (l+lp-x1)
  Y = (h-y1)
  z = (l4**2 - (X**2 + Y**2 + r2**2))/(2*r2)
  beta = np.arcsin(X/np.sqrt(X**2 + Y**2)) - np.arcsin(z/np.sqrt(X**2 + Y**2))
  return beta

def third_wheel_circle1(x4, y4, l34, r3):
  X = (l+lp-x4)
  Y = (h-hp-y4)
  z = (l34**2 - (X**2 + Y**2 + r3**2))/(2*r3)
  beta = np.arcsin(X/np.sqrt(X**2 + Y**2)) - np.arcsin(z/np.sqrt(X**2 + Y**2))
  return beta

def third_wheel_circle2(x4, y4, l34, r3):
  X = (l+lp-x4)
  Y = (h-y4)
  z = (l34**2 - (X**2 + Y**2 + r3**2))/(2*r3)
  beta = np.arcsin(X/np.sqrt(X**2 + Y**2)) - np.arcsin(z/np.sqrt(X**2 + Y**2))
  return beta

# Path generation
def path_generate(x1, y1, r1, tol):
  y_checkpoint1 = round(h-hp - np.sqrt(r1**2 - (x1-(l+lp))**2), 2)
  y_path = np.linspace(y1, y_checkpoint1, round((h-hp)/tol), dtype=float)
  x_path = np.ones(round((h-hp)/tol), dtype=float)*x1

  x_points, y_points = arc(x1, y_checkpoint1, l+lp+r1, h-hp, l+lp, h-hp, round(((h-hp) - y_checkpoint1)/tol))
  x_path = np.append(x_path, x_points)
  y_path = np.append(y_path, y_points)

  y_path = np.append(y_path, np.linspace(h-hp, h, round(hp/tol), dtype=float))
  x_path = np.append(x_path, (l+lp+r1)*np.ones(round(hp/tol), dtype=float))

  x_points, y_points = arc(l+lp+r1, h, l+lp, h+r1, l+lp, h, round((r1)/tol))
  x_path = np.append(x_path, x_points)
  y_path = np.append(y_path, y_points)

  x_path = np.append(x_path, np.linspace((l+lp), r1, round(l/tol), dtype=float))
  y_path = np.append(y_path, (h+r1)*np.ones(round(l/tol), dtype=float))

  return x_path, y_path

def distances_check(data, row):
  l1 = row['l1']
  l2 = row['l2']
  l3 = row['l3']
  l4 = row['l4']
  l5 = row['l5']
  l6 = row['l6']
  l7 = row['l7']

  x1 = data['x1_0']
  y1 = data['y1_1']
  x2 = data['x2_2']
  y2 = data['y2_3']
  x3 = data['x3_4']
  y3 = data['y3_5']
  x4 = data['x4_6']
  y4 = data['y4_7']
  x5 = data['x5_8']
  y5 = data['y5_9']
  x6 = data['x6_10']
  y6 = data['y6_11']

  distance12 = distance((x1, y1), (x2, y2))
  distance14 = distance((x1, y1), (x4, y4))
  distance24 = distance((x2, y2), (x4, y4))
  distance35 = distance((x3, y3), (x5, y5))
  distance45 = distance((x4, y4), (x5, y5))
  distance46 = distance((x4, y4), (x6, y6))

  d12 = np.abs(distance12 - l4)
  d14 = np.abs(distance14 - l1)
  d24 = np.abs(distance24 - l2)
  d45 = np.abs(distance45 - l3)
  d46 = np.abs(distance46 - l6)
  d35 = np.abs(distance35 - l7)

  if(d12<2 and d14<2 and d24<2 and d45<2 and d46<2 and d35<2):
    return True
  else:
    return False

def gamma_function(x,y):
  if(y<h):
    return np.pi/2
  else:
    a = slope(x, y, l+lp, h)
    a = a-np.pi/2 if a>np.pi/2 else 0 if a<np.pi/2  else np.pi/2
    return a

def assumptions_check(row):
  Y1 = row['Y1']
  Y2 = row['Y2']
  a20 = row['a20']
  a2 = row['a2']
  a30 = row['a30']
  a3 = row['a3']
  tb = row['tb']
  bx = row['bx']
  by = row['by']
  ADC = row['ADC']

  if (Y1<65*np.pi/180 or Y2<np.pi/2 or bx>0 or by>0) and ADC:
    return True
  else:
    return False

def assumptions(row):
  Y1 = row['Y1']
  Y2 = row['Y2']
  a20 = row['a20']
  a2 = row['a2']
  a30 = row['a30']
  a3 = row['a3']
  tb = row['tb']
  bx = row['bx']
  by = row['by']
  l1 = row['l1']
  l2 = row['l2']
  l3 = row['l3']
  l4 = row['l4']
  r1 = row['r1']
  r2 = row['r2']
  r3 = row['r3']
  ADC = row['ADC']

  h1 = np.sqrt(np.abs(l4**2 - (r2 - r2*np.sin(Y1))**2)) - r1*np.cos(Y1) + r2
  h2 = l4*np.sin(tb) - r1*np.cos(Y1) + r2
  h3 = - l3*np.sin(tb + a30 + a3 - a20) - by + r3
  h4 = np.sqrt(np.abs(l3**2 - (r3+bx)**2)) - by + r3
  h5 = l3*np.sin(a3) - by + r3

  return min(h1, h4, h5) if ADC else np.nan

def SN_ratio(data, row):
  if(row['ADC']):
    y_curve = np.array(data.iloc[:,11])
    x_curve = np.array(data.iloc[:,10])

    m,_ = line_equation((l+lp, 2*h), (2*(l+lp), h))
    c = y_curve[0] - m*x_curve[0]
    y_line = m * x_curve + c

    area_curve = simps(y_curve, x_curve)
    area_line = simps(y_line, x_curve)
    area_between = np.abs(area_curve - area_line)

    SN_ratio = -10*np.log10(area_between**2)
    return SN_ratio

def plot_SN_curve(data):

  y_curve = np.array(data.iloc[:,11])
  x_curve = np.array(data.iloc[:,10])

  m,_ = line_equation((l+lp, 2*h), (2*(l+lp), h))
  c = y_curve[0] - m*x_curve[0]
  y_line = m * x_curve + c

  area_curve = simps(y_curve, x_curve)
  area_line = simps(y_line, x_curve)
  area_between = np.abs(area_curve - area_line)

  plt.plot(x_curve, y_curve, label='Curve')
  plt.plot(x_curve, y_line, label='Line', linestyle='--')
  plt.fill_between(x_curve, y_curve, y_line, where=(y_curve > y_line), color='lightgreen', alpha=0.5)
  plt.fill_between(x_curve, y_curve, y_line, where=(y_curve < y_line), color='lightcoral', alpha=0.5)
  plt.gca().invert_xaxis()
  plt.legend()
  plt.show()
  print(f"\n Area between the curve and the line: {area_between}")

main_dataframe = constraints_function(main_df)
main_dataframe = main_dataframe.reset_index(drop=True)
main_dataframe

"""### Actual code snippet"""

# # Intial positions and coordinate system definition
# x1, y1, y2, y3 = r1 + l, r1, r2, r3
# x2 = np.sqrt(l4**2 - (y2 - y1)**2) + x1
# alpha2 = np.arccos((l2**2 + l4**2 - l1**2)/(2*l2*l4))
# alpha4 = np.arccos((l2**2 + l1**2 - l4**2)/(2*l2*l1))
# alpha1 = np.pi - (alpha2 + alpha4)

# # # Calculation of the coordinates of point 4 (third vertex of the front traingle)
# theeta = slope(x1, y1, x2, y2)
# if(theeta >= np.pi/2):
#   theeta = np.pi - theeta
#   if(np.abs(alpha1 - theeta)<0.009):
#     x4 = x1
#     y4 = y1+l1
#   elif(alpha1 - theeta<0):
#     x4 = round(x1 + l1*np.cos(alpha1 - theeta), 2)
#     y4 = round(y1 + l1*np.sin(alpha1 - theeta), 2)
#   else:
#     x4 = round(x1 + l1*np.cos(theeta - alpha1), 2)
#     y4 = round(y1 - l1*np.sin(theeta - alpha1), 2)
# else:
#   x4 = round(x1 + l1*np.cos(alpha1 + theeta), 2)
#   y4 = round(y1 + l1*np.sin(alpha1 + theeta), 2)

# # Calculation of l7
# m, c = line_equation((x1, y1), (x2, y2))
# yy = m*x4 + c
# l7 = round(y4 - yy, 2)

# # Calculation of the coordinates of point 3 (third wheel coordinates)
# l34 = np.sqrt(l3**2 + l7**2)
# x3 = round(np.sqrt(l34**2 - (y3 - y4)**2) + x4)
# alpha3 = np.arctan(l3/l7)

# # Calculation of the coordinates of point 5 (above third wheel)
# gamma = slope(x4, y4, x3, y3)
# if(gamma>=np.pi/2):
#   gamma = np.pi - gamma
#   if(np.abs((gamma+alpha3) - np.pi/2)<0.009):
#     x5 = x3
#     y5 = y3+l7
#   elif(gamma+alpha3)<np.pi/2:
#     x5 = round(x3 - l7*np.sin(np.pi/2 - gamma - alpha3), 2)
#     y5 = round(y3 + l7*np.cos(np.pi/2 - gamma - alpha3), 2)
#   else:
#     x5 = round(x3 + l7*np.sin(alpha3 + gamma - np.pi/2), 2)
#     y5 = round(y3 + l7*np.cos(alpha3 + gamma - np.pi/2), 2)
# else:
#   x5 = round(x3 - l7*np.sin(np.pi/2 - alpha3 + gamma), 2)
#   y5 = round(y3 + l7*np.cos(np.pi/2 - alpha3 + gamma), 2)

# # Calculation of the coordinates of the centre of mass (CM coordinates)
# beta = slope(x5, y5, x4, y4)
# x6 = round(x4 - l6*np.sin(beta)) if np.degrees(beta)<90 else round(x4 + l6*np.sin(np.pi - beta))
# y6 = round(y4 + l6*np.cos(beta)) if np.degrees(beta)<90 else round(y4 + l6*np.cos(np.pi - beta))

# x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6

# # Plotting the initial position of the robot
# x14 = np.array([x1, x4])
# y14 = np.array([y1, y4])

# x24 = np.array([x2, x4])
# y24 = np.array([y2, y4])

# x35 = np.array([x3, x5])
# y35 = np.array([y3, y5])

# x45 = np.array([x4, x5])
# y45 = np.array([y4, y5])

# x46 = np.array([x4, x6])
# y46 = np.array([y4, y6])

# circle_angle = np.linspace(0, 2 * np.pi, 100)
# x1c = x1 + r1 * np.cos(circle_angle)
# y1c = y1 + r1 * np.sin(circle_angle)

# x2c = x2 + r2 * np.cos(circle_angle)
# y2c = y2 + r2 * np.sin(circle_angle)

# x3c = x3 + r3 * np.cos(circle_angle)
# y3c = y3 + r3 * np.sin(circle_angle)

# plt.figure(figsize=(20, 10))
# plt.plot(x1c, y1c, color='black', linewidth=2)
# plt.plot(x2c, y2c, color='black', linewidth=2)
# plt.plot(x3c, y3c, color='black', linewidth=2)
# plt.plot(x14, y14, color='black', linewidth=2, label="l1")
# plt.plot(x24, y24, color='black', linewidth=2, label="l2")
# plt.plot(x35, y35, color='black', linewidth=2, label="l7")
# plt.plot(x45, y45, color='black', linewidth=2, label="l3")
# plt.plot(x46, y46, color='black', linewidth=2, label="l6")
# plt.plot([l, 660], [0, 0], color='black', linewidth=2, label="ground")
# plt.plot([l, l], [0, h-hp], color='black', linewidth=2, label="height")
# plt.plot([l, l+lp], [h-hp, h-hp], color='black', linewidth=2, label="width of the protruding part")
# plt.plot([l+lp, l+lp], [h-hp, h], color='black', linewidth=2, label="width of the protruding part")
# plt.plot([0, l+lp], [h, h], color='black', linewidth=2, label="width")
# # plt.xlim(0, 660)
# # plt.ylim(-2, 150)
# plt.grid()
# plt.show()

# print("\n Distance between (x1, y1) and (x2, y2): ",distance((x1, y1), (x2, y2)))
# print("\n Distance between (x1, y1) and (x4, y4): ",distance((x1, y1), (x4, y4)))
# print("\n Distance between (x2, y2) and (x4, y4): ",distance((x2, y2), (x4, y4)))
# print("\n Distance between (x3, y3) and (x5, y5): ",distance((x3, y3), (x5, y5)))
# print("\n Distance between (x4, y4) and (x5, y5): ",distance((x4, y4), (x5, y5)))
# print("\n Distance between (x4, y4) and (x6, y6): ",distance((x4, y4), (x6, y6)))

# x_path, y_path = path_generate(x1, y1, 0.1)

# plt.figure(figsize=(20, 10))
# plt.plot(x_path, y_path, color="red", linewidth=3, label="path")
# plt.plot([l, 660], [0, 0], color='black', linewidth=2, label="ground")
# plt.plot([l, l], [0, h-hp], color='black', linewidth=2, label="height")
# plt.plot([l, l+lp], [h-hp, h-hp], color='black', linewidth=2, label="width of the protruding part")
# plt.plot([l+lp, l+lp], [h-hp, h], color='black', linewidth=2, label="width of the protruding part")
# plt.plot([0, l+lp], [h, h], color='black', linewidth=2, label="width")
# plt.gca().invert_xaxis()
# plt.grid()
# plt.show()

# # Trajectory generation
# def trajectory(x1, y1, x2, y2):
#   if(x2-l>1):
#     theeta = slope(x1, y1, x2, y2)
#     x4 = round(x2 + l2*np.cos(alpha2 + theeta), 2) if np.degrees(theeta+alpha2)>90 else round(x2 - l2*np.cos(alpha2 + theeta), 2)
#     y4 = round(y2 + l2*np.sin(alpha2 + theeta), 2)
#     y3 = r3
#     x3 = round(np.sqrt(l34**2 - (y3 - y4)**2) + x4)
#     gamma = np.pi - slope(x4, y4, x3, y3)
#     x5 = round(x3 - l7*np.cos(alpha3 + gamma), 2) if np.degrees(gamma+alpha3)<=90 else round(x3 + l7*np.cos(alpha3 + gamma), 2)
#     y5 = round(y3 + l7*np.sin(alpha3 + gamma), 2)
#     beta = slope(x5, y5, x3, y3)
#     x6 = round(x4 + l6*np.cos(beta)) if np.degrees(beta)<90 else round(x4 - l6*np.cos(np.pi - beta))
#     y6 = round(y4 + l6*np.sin(beta)) if np.degrees(beta)<90 else round(y4 + l6*np.sin(np.pi - beta))

#     return x3, y3, x4, y4, x5, y5, x6, y6
#   else:
#     return np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan

# df = pd.DataFrame(np.nan, index=range(len(x_path)), columns=['x1_0', 'y1_1', 'x2_2', 'y2_3', 'x3_4', 'y3_5', 'x4_6', 'y4_7', 'x5_8', 'y5_9', 'x6_10', 'y6_11'])
# df.iloc[:,0] = x_path
# df.iloc[:,1] = y_path
# df.iloc[0,2] = x2
# df.iloc[0,3] = y2
# df.iloc[0,4] = x3
# df.iloc[0,5] = y3
# df.iloc[0,6] = x4
# df.iloc[0,7] = y4
# df.iloc[0,8] = x5
# df.iloc[0,9] = y5
# df.iloc[0,10] = x6
# df.iloc[0,11] = y6
# df

# i = 1;
# checkpoint1 = True
# while(checkpoint1):
#   if(df.iloc[i-1,2]-l-r2>0.5):

#     df.iloc[i,3] = r2
#     df.iloc[i,2] = np.sqrt(np.abs(l4**2 - (df.iloc[i,3] - df.iloc[i,1])**2)) + df.iloc[i,0]

#     theeta = slope(df.iloc[i,0], df.iloc[i,1], df.iloc[i,2], df.iloc[i,3])
#     if(theeta >= np.pi/2):
#       theeta = np.pi - theeta
#       if(np.abs(alpha1 - theeta)<0.009):
#         df.iloc[i,6] = df.iloc[i,0] + l1
#         df.iloc[i,7] = df.iloc[i,1]
#       elif(alpha1 - theeta>0):
#         df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 - theeta), 2)
#         df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 - theeta), 2)
#       else:
#         df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(theeta - alpha1), 2)
#         df.iloc[i,7] = round(df.iloc[i,1] - l1*np.sin(theeta - alpha1), 2)
#     else:
#       df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 + theeta), 2)
#       df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 + theeta), 2)

#     df.iloc[i,5] = r3
#     df.iloc[i,4] = round(np.sqrt(l34**2 - (df.iloc[i,5] - df.iloc[i,7])**2) + df.iloc[i,6], 2)

#     gamma = slope(df.iloc[i,6], df.iloc[i,7], df.iloc[i,4], df.iloc[i,5])
#     if(gamma>=np.pi/2):
#       gamma = np.pi - gamma
#       if(np.abs((gamma+alpha3) - np.pi/2)<0.009):
#         df.iloc[i,8] = df.iloc[i,4]
#         df.iloc[i,9] = df.iloc[i,5]+l7
#       elif(gamma+alpha3)<np.pi/2:
#         df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - gamma - alpha3), 2)
#         df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - gamma - alpha3), 2)
#       else:
#         df.iloc[i,8] = round(df.iloc[i,4] + l7*np.sin(alpha3 + gamma - np.pi/2), 2)
#         df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(alpha3 + gamma - np.pi/2), 2)
#     else:
#       df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - alpha3 + gamma), 2)
#       df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - alpha3 + gamma), 2)

#     beta = slope(df.iloc[i,8], df.iloc[i,9], df.iloc[i,6], df.iloc[i,7])
#     df.iloc[i,10] = round(df.iloc[i,6] - l6*np.sin(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,6] + l6*np.sin(np.pi - beta), 2)
#     df.iloc[i,11] = round(df.iloc[i,7] + l6*np.cos(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,7] + l6*np.cos(np.pi - beta), 2)

#     i = i+1

#   else:
#     checkpoint1 = False

# k = i

/

# # Plotting the initial position of the robot
# x14 = np.array([df.iloc[i-1,0], df.iloc[i-1,6]])
# y14 = np.array([df.iloc[i-1,1], df.iloc[i-1,7]])

# x24 = np.array([df.iloc[i-1,2], df.iloc[i-1,6]])
# y24 = np.array([df.iloc[i-1,3], df.iloc[i-1,7]])

# x35 = np.array([df.iloc[i-1,4], df.iloc[i-1,8]])
# y35 = np.array([df.iloc[i-1,5], df.iloc[i-1,9]])

# x45 = np.array([df.iloc[i-1,6], df.iloc[i-1,8]])
# y45 = np.array([df.iloc[i-1,7], df.iloc[i-1,9]])

# x46 = np.array([df.iloc[i-1,6], df.iloc[i-1,10]])
# y46 = np.array([df.iloc[i-1,7], df.iloc[i-1,11]])

# circle_angle = np.linspace(0, 2 * np.pi, 100)
# x1c = df.iloc[i-1,0] + r1 * np.cos(circle_angle)
# y1c = df.iloc[i-1,1] + r1 * np.sin(circle_angle)

# x2c = df.iloc[i-1,2] + r2 * np.cos(circle_angle)
# y2c = df.iloc[i-1,3] + r2 * np.sin(circle_angle)

# x3c = df.iloc[i-1,4] + r3 * np.cos(circle_angle)
# y3c = df.iloc[i-1,5] + r3 * np.sin(circle_angle)

# plt.figure(figsize=(20, 10))
# plt.plot(x1c, y1c, color='black', linewidth=2)
# plt.plot(x2c, y2c, color='black', linewidth=2)
# plt.plot(x3c, y3c, color='black', linewidth=2)
# plt.plot(x14, y14, color='black', linewidth=2, label="l1")
# plt.plot(x24, y24, color='black', linewidth=2, label="l2")
# plt.plot(x35, y35, color='black', linewidth=2, label="l7")
# plt.plot(x45, y45, color='black', linewidth=2, label="l3")
# plt.plot(x46, y46, color='black', linewidth=2, label="l6")
# plt.plot([l, 660], [0, 0], color='black', linewidth=2, label="ground")
# plt.plot([l, l], [0, h-hp], color='black', linewidth=2, label="height")
# plt.plot([l, l+lp], [h-hp, h-hp], color='black', linewidth=2, label="width of the protruding part")
# plt.plot([l+lp, l+lp], [h-hp, h], color='black', linewidth=2, label="width of the protruding part")
# plt.plot([0, l+lp], [h, h], color='black', linewidth=2, label="width")
# # plt.xlim(0, 660)
# # plt.ylim(-2, 150)
# plt.gca().invert_xaxis()
# plt.grid()
# plt.show()

# print("\n Distance between (x1, y1) and (x2, y2): ",distance((df.iloc[i,0], df.iloc[i,1]), (df.iloc[i,2], df.iloc[i,3])))
# print("\n Distance between (x1, y1) and (x4, y4): ",distance((df.iloc[i,0], df.iloc[i,1]), (df.iloc[i,6], df.iloc[i,7])))
# print("\n Distance between (x2, y2) and (x4, y4): ",distance((df.iloc[i,2], df.iloc[i,3]), (df.iloc[i,6], df.iloc[i,7])))
# print("\n Distance between (x3, y3) and (x5, y5): ",distance((df.iloc[i,4], df.iloc[i,5]), (df.iloc[i,8], df.iloc[i,9])))
# print("\n Distance between (x4, y4) and (x5, y5): ",distance((df.iloc[i,6], df.iloc[i,7]), (df.iloc[i,8], df.iloc[i,9])))
# print("\n Distance between (x4, y4) and (x6, y6): ",distance((df.iloc[i,6], df.iloc[i,7]), (df.iloc[i,10], df.iloc[i,11])))

# ch1 = True
# ch2 = True
# ch3 = True
# ch4 = True
# y2checkpoint1 = round(h-hp - np.sqrt(np.abs(r2**2 - (lp-r2)**2)), 2)
# y2checkpoint2 = h-hp
# y2checkpoint3 = h
# y2checkpoint4 = h+r2
# x2checkpoint1 = round(r1 + np.sqrt(l4**2 - (r2-r1)**2), 2)
# maxi = df.shape[0]
# while(ch1!=False or ch2!=False or ch3!=False or ch4!=False) and i<maxi:
#   if(y2checkpoint1-df.iloc[i-1,3]>0.01):
#     df.iloc[i,2] = l+r2
#     df.iloc[i,3] = round(df.iloc[i,1] - np.sqrt(np.abs(l4**2 - (df.iloc[i,2] - df.iloc[i,0])**2)), 2)
#   elif(y2checkpoint2 - df.iloc[i-1,3]>0.01):
#     ch1 = False
#     angle = second_wheel_circle1(df.iloc[i,0], df.iloc[i,1])
#     df.iloc[i,2] = round(l+lp + r2*np.cos(angle), 2)
#     df.iloc[i,3] = round(h-hp + r2*np.sin(angle), 2)
#   elif(y2checkpoint3 - df.iloc[i-1,3]>0.01):
#     ch2 = False
#     df.iloc[i,2] = l+lp+r2
#     df.iloc[i,3] = round(df.iloc[i,1] - np.sqrt(np.abs(l4**2 - (df.iloc[i,2] - df.iloc[i,0])**2)), 2)
#   elif(y2checkpoint4 - df.iloc[i-1,3]>0.01):
#     ch3 = False
#     angle = second_wheel_circle2(df.iloc[i,0], df.iloc[i,1])
#     df.iloc[i,2] = round(l+lp + r2*np.cos(angle), 2)
#     df.iloc[i,3] = round(h + r2*np.sin(angle), 2)
#   elif(df.iloc[i-1,2] - x2checkpoint1>0.01):
#     df.iloc[i,3] = h+r2
#     df.iloc[i,2] = round(df.iloc[i,0] + np.sqrt(np.abs(l4**2 - (df.iloc[i,3] - df.iloc[i,1])**2)), 2)
#   else:
#     ch4=False
#   i=i+1

# x_path, y_path = path_generate(x1, y1, 0.1)

# plt.figure(figsize=(20, 10))
# plt.plot(x_path, y_path, color="red", linewidth=3, label="path")
# plt.plot(df.iloc[:i,2], df.iloc[:i,3], color="blue", linewidth=5)
# plt.plot([l, 660], [0, 0], color='black', linewidth=2, label="ground")
# plt.plot([l, l], [0, h-hp], color='black', linewidth=2, label="height")
# plt.plot([l, l+lp], [h-hp, h-hp], color='black', linewidth=2, label="width of the protruding part")
# plt.plot([l+lp, l+lp], [h-hp, h], color='black', linewidth=2, label="width of the protruding part")
# plt.plot([0, l+lp], [h, h], color='black', linewidth=2, label="width")
# plt.gca().invert_xaxis()
# plt.grid()
# plt.show()

# checkpoint2 = True
# i = k
# while(checkpoint2):
#   if(df.iloc[i-1,4]-l-r3>0.5):

#     theeta = slope(df.iloc[i,0], df.iloc[i,1], df.iloc[i,2], df.iloc[i,3])
#     if(theeta >= np.pi/2):
#       theeta = np.pi - theeta
#       if(np.abs(alpha1 - theeta)<0.009):
#         df.iloc[i,6] = df.iloc[i,0] + l1
#         df.iloc[i,7] = df.iloc[i,1]
#       elif(alpha1 - theeta>0):
#         df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 - theeta), 2)
#         df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 - theeta), 2)
#       else:
#         df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(theeta - alpha1), 2)
#         df.iloc[i,7] = round(df.iloc[i,1] - l1*np.sin(theeta - alpha1), 2)
#     else:
#       df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 + theeta), 2)
#       df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 + theeta), 2)

#     df.iloc[i,5] = r3
#     df.iloc[i,4] = round(np.sqrt(l34**2 - (df.iloc[i,5] - df.iloc[i,7])**2) + df.iloc[i,6], 2)

#     gamma = slope(df.iloc[i,6], df.iloc[i,7], df.iloc[i,4], df.iloc[i,5])
#     if(gamma>=np.pi/2):
#       gamma = np.pi - gamma
#       if(np.abs((gamma+alpha3) - np.pi/2)<0.009):
#         df.iloc[i,8] = df.iloc[i,4]
#         df.iloc[i,9] = df.iloc[i,5]+l7
#       elif(gamma+alpha3)<np.pi/2:
#         df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - gamma - alpha3), 2)
#         df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - gamma - alpha3), 2)
#       else:
#         df.iloc[i,8] = round(df.iloc[i,4] + l7*np.sin(alpha3 + gamma - np.pi/2), 2)
#         df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(alpha3 + gamma - np.pi/2), 2)
#     else:
#       df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - alpha3 + gamma), 2)
#       df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - alpha3 + gamma), 2)

#     beta = slope(df.iloc[i,8], df.iloc[i,9], df.iloc[i,6], df.iloc[i,7])
#     df.iloc[i,10] = round(df.iloc[i,6] - l6*np.sin(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,6] + l6*np.sin(np.pi - beta), 2)
#     df.iloc[i,11] = round(df.iloc[i,7] + l6*np.cos(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,7] + l6*np.cos(np.pi - beta), 2)

#     i = i+1
#   else:
#     checkpoint2 = False

# k = i

# for i in range(k,df.shape[0]):
#   theeta = slope(df.iloc[i,0], df.iloc[i,1], df.iloc[i,2], df.iloc[i,3])
#   if(theeta >= np.pi/2):
#     theeta = np.pi - theeta
#     if(np.abs(alpha1 - theeta)<0.009):
#       df.iloc[i,6] = df.iloc[i,0] + l1
#       df.iloc[i,7] = df.iloc[i,1]
#     elif(alpha1 - theeta>0):
#       df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 - theeta), 2)
#       df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 - theeta), 2)
#     else:
#       df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(theeta - alpha1), 2)
#       df.iloc[i,7] = round(df.iloc[i,1] - l1*np.sin(theeta - alpha1), 2)
#   else:
#     df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 + theeta), 2)
#     df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 + theeta), 2)

# ch1 = True
# ch2 = True
# ch3 = True
# ch4 = True
# y3checkpoint1 = round(h-hp - np.sqrt(np.abs(r3**2 - (lp-r3)**2)), 2)
# y3checkpoint2 = h-hp
# y3checkpoint3 = h
# y3checkpoint4 = h+r3
# x3checkpoint1 = round(df.iloc[-1,6] + np.sqrt(l34**2 - (df.iloc[-1,7]-r3)**2), 2)
# maxi = df.shape[0]
# i = k
# while(ch1!=False or ch2!=False or ch3!=False or ch4!=False) and i<maxi:
#   if(y3checkpoint1-df.iloc[i-1,5]>0.01):
#     df.iloc[i,4] = l+r3
#     df.iloc[i,5] = round(df.iloc[i,7] - np.sqrt(np.abs(l34**2 - (df.iloc[i,6] - df.iloc[i,4])**2)), 2)
#   elif(y3checkpoint2 - df.iloc[i-1,5]>0.01):
#     ch1 = False
#     angle = third_wheel_circle1(df.iloc[i,6], df.iloc[i,7])
#     df.iloc[i,4] = round(l+lp + r3*np.cos(angle), 2)
#     df.iloc[i,5] = round(h-hp + r3*np.sin(angle), 2)
#   elif(y3checkpoint3 - df.iloc[i-1,5]>0.01):
#     ch2 = False
#     df.iloc[i,4] = l+lp+r2
#     df.iloc[i,5] = round(df.iloc[i,7] - np.sqrt(np.abs(l34**2 - (df.iloc[i,6] - df.iloc[i,4])**2)), 2)
#   elif(y3checkpoint4 - df.iloc[i-1,5]>0.01):
#     ch3 = False
#     angle = third_wheel_circle2(df.iloc[i,6], df.iloc[i,7])
#     df.iloc[i,4] = round(l+lp + r3*np.cos(angle), 2)
#     df.iloc[i,5] = round(h + r3*np.sin(angle), 2)
#   elif(df.iloc[i-1,4] - x3checkpoint1>0.01):
#     df.iloc[i,5] = h+r2
#     df.iloc[i,4] = round(df.iloc[i,6] + np.sqrt(np.abs(l34**2 - (df.iloc[i,5] - df.iloc[i,7])**2)), 2)
#   else:
#     ch4=False
#   i=i+1

# for i in range(k, df.shape[0]):
#   gamma = slope(df.iloc[i,6], df.iloc[i,7], df.iloc[i,4], df.iloc[i,5])
#   if(gamma>=np.pi/2):
#     gamma = np.pi - gamma
#     if(np.abs((gamma+alpha3) - np.pi/2)<0.009):
#       df.iloc[i,8] = df.iloc[i,4]
#       df.iloc[i,9] = df.iloc[i,5]+l7
#     elif(gamma+alpha3)<np.pi/2:
#       df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - gamma - alpha3), 2)
#       df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - gamma - alpha3), 2)
#     else:
#       df.iloc[i,8] = round(df.iloc[i,4] + l7*np.sin(alpha3 + gamma - np.pi/2), 2)
#       df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(alpha3 + gamma - np.pi/2), 2)
#   else:
#     df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - alpha3 + gamma), 2)
#     df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - alpha3 + gamma), 2)

#   beta = slope(df.iloc[i,8], df.iloc[i,9], df.iloc[i,6], df.iloc[i,7])
#   df.iloc[i,10] = round(df.iloc[i,6] - l6*np.sin(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,6] + l6*np.sin(np.pi - beta), 2)
#   df.iloc[i,11] = round(df.iloc[i,7] + l6*np.cos(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,7] + l6*np.cos(np.pi - beta), 2)

"""### Code snippet"""

def trajectory_function(row):

  l1 = row['l1']
  l2 = row['l2']
  l3 = row['l3']
  l4 = row['l4']
  l5 = row['l5']
  l6 = row['l6']

  r1 = row['r1']
  r2 = row['r2']
  r3 = row['r3']

    # Intial positions and coordinate system definition
  x1, y1, y2, y3 = r1 + l, r1, r2, r3
  x2 = np.sqrt(l4**2 - (y2 - y1)**2) + x1
  alpha2 = np.arccos((l2**2 + l4**2 - l1**2)/(2*l2*l4))
  alpha4 = np.arccos((l2**2 + l1**2 - l4**2)/(2*l2*l1))
  alpha1 = np.pi - (alpha2 + alpha4)

  # # Calculation of the coordinates of point 4 (third vertex of the front traingle)
  theeta = slope(x1, y1, x2, y2)
  if(theeta >= np.pi/2):
    theeta = np.pi - theeta
    if(np.abs(alpha1 - theeta)<0.009):
      x4 = x1
      y4 = y1+l1
    elif(alpha1 - theeta<0):
      x4 = round(x1 + l1*np.cos(alpha1 - theeta), 2)
      y4 = round(y1 + l1*np.sin(alpha1 - theeta), 2)
    else:
      x4 = round(x1 + l1*np.cos(theeta - alpha1), 2)
      y4 = round(y1 - l1*np.sin(theeta - alpha1), 2)
  else:
    x4 = round(x1 + l1*np.cos(alpha1 + theeta), 2)
    y4 = round(y1 + l1*np.sin(alpha1 + theeta), 2)

  # Calculation of l7
  m, c = line_equation((x1, y1), (x2, y2))
  yy = m*x4 + c
  l7 = round(y4 - yy, 2)
  row.loc['l7'] = l7

  # Calculation of the coordinates of point 3 (third wheel coordinates)
  l34 = np.sqrt(l3**2 + l7**2)
  x3 = round(np.sqrt(l34**2 - (y3 - y4)**2) + x4)
  alpha3 = np.arctan(l3/l7)

  # Calculation of the coordinates of point 5 (above third wheel)
  gamma = slope(x4, y4, x3, y3)
  if(gamma>=np.pi/2):
    gamma = np.pi - gamma
    if(np.abs((gamma+alpha3) - np.pi/2)<0.009):
      x5 = x3
      y5 = y3+l7
    elif(gamma+alpha3)<np.pi/2:
      x5 = round(x3 - l7*np.sin(np.pi/2 - gamma - alpha3), 2)
      y5 = round(y3 + l7*np.cos(np.pi/2 - gamma - alpha3), 2)
    else:
      x5 = round(x3 + l7*np.sin(alpha3 + gamma - np.pi/2), 2)
      y5 = round(y3 + l7*np.cos(alpha3 + gamma - np.pi/2), 2)
  else:
    x5 = round(x3 - l7*np.sin(np.pi/2 - alpha3 + gamma), 2)
    y5 = round(y3 + l7*np.cos(np.pi/2 - alpha3 + gamma), 2)

  # Calculation of the coordinates of the centre of mass (CM coordinates)
  beta = slope(x5, y5, x4, y4)
  x6 = round(x4 - l6*np.sin(beta)) if np.degrees(beta)<90 else round(x4 + l6*np.sin(np.pi - beta))
  y6 = round(y4 + l6*np.cos(beta)) if np.degrees(beta)<90 else round(y4 + l6*np.cos(np.pi - beta))
  row.loc['a20'] = alpha2
  row.loc['a30'] = 0

  x_path, y_path = path_generate(x1, y1, r1, 0.1)
  df = pd.DataFrame(np.nan, index=range(len(x_path)), columns=['x1_0', 'y1_1', 'x2_2', 'y2_3', 'x3_4', 'y3_5', 'x4_6', 'y4_7', 'x5_8', 'y5_9', 'x6_10', 'y6_11'])
  df.iloc[:,0] = x_path
  df.iloc[:,1] = y_path
  df.iloc[0,2] = x2
  df.iloc[0,3] = y2
  df.iloc[0,4] = x3
  df.iloc[0,5] = y3
  df.iloc[0,6] = x4
  df.iloc[0,7] = y4
  df.iloc[0,8] = x5
  df.iloc[0,9] = y5
  df.iloc[0,10] = x6
  df.iloc[0,11] = y6

  i = 1
  checkpoint1 = True
  while(checkpoint1):
    if(df.iloc[i-1,2]-l-r2>0.5):

      df.iloc[i,3] = r2
      df.iloc[i,2] = np.sqrt(np.abs(l4**2 - (df.iloc[i,3] - df.iloc[i,1])**2)) + df.iloc[i,0]

      theeta = slope(df.iloc[i,0], df.iloc[i,1], df.iloc[i,2], df.iloc[i,3])
      if(theeta >= np.pi/2):
        theeta = np.pi - theeta
        if(np.abs(alpha1 - theeta)<0.009):
          df.iloc[i,6] = df.iloc[i,0] + l1
          df.iloc[i,7] = df.iloc[i,1]
        elif(alpha1 - theeta>0):
          df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 - theeta), 2)
          df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 - theeta), 2)
        else:
          df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(theeta - alpha1), 2)
          df.iloc[i,7] = round(df.iloc[i,1] - l1*np.sin(theeta - alpha1), 2)
      else:
        df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 + theeta), 2)
        df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 + theeta), 2)

      df.iloc[i,5] = r3
      df.iloc[i,4] = round(np.sqrt(l34**2 - (df.iloc[i,5] - df.iloc[i,7])**2) + df.iloc[i,6], 2)

      gamma = slope(df.iloc[i,6], df.iloc[i,7], df.iloc[i,4], df.iloc[i,5])
      if(gamma>=np.pi/2):
        gamma = np.pi - gamma
        if(np.abs((gamma+alpha3) - np.pi/2)<0.009):
          df.iloc[i,8] = df.iloc[i,4]
          df.iloc[i,9] = df.iloc[i,5]+l7
        elif(gamma+alpha3)<np.pi/2:
          df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - gamma - alpha3), 2)
          df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - gamma - alpha3), 2)
        else:
          df.iloc[i,8] = round(df.iloc[i,4] + l7*np.sin(alpha3 + gamma - np.pi/2), 2)
          df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(alpha3 + gamma - np.pi/2), 2)
      else:
        df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - alpha3 + gamma), 2)
        df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - alpha3 + gamma), 2)

      beta = slope(df.iloc[i,8], df.iloc[i,9], df.iloc[i,6], df.iloc[i,7])
      df.iloc[i,10] = round(df.iloc[i,6] - l6*np.sin(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,6] + l6*np.sin(np.pi - beta), 2)
      df.iloc[i,11] = round(df.iloc[i,7] + l6*np.cos(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,7] + l6*np.cos(np.pi - beta), 2)

      i = i+1

    else:
      checkpoint1 = False

  row.loc['tb'] = slope(df.iloc[i-1,0], df.iloc[i-1,1], df.iloc[i-1,2], df.iloc[i-1,3])
  row.loc['Y1'] = gamma_function(df.iloc[i-1,0], df.iloc[i-1,1])
  row.loc['ADC'] = distances_check(df.iloc[i-1], row)

  k = i

  ch1 = True
  ch2 = True
  ch3 = True
  ch4 = True
  y2checkpoint1 = round(h-hp - np.sqrt(np.abs(r2**2 - (lp-r2)**2)), 2)
  y2checkpoint2 = h-hp
  y2checkpoint3 = h
  y2checkpoint4 = h+r2
  x2checkpoint1 = round(r1 + np.sqrt(l4**2 - (r2-r1)**2), 2)
  maxi = df.shape[0]
  while(ch1!=False or ch2!=False or ch3!=False or ch4!=False) and i<maxi:
    if(y2checkpoint1-df.iloc[i-1,3]>0.01):
      df.iloc[i,2] = l+r2
      df.iloc[i,3] = round(df.iloc[i,1] - np.sqrt(np.abs(l4**2 - (df.iloc[i,2] - df.iloc[i,0])**2)), 2)
    elif(y2checkpoint2 - df.iloc[i-1,3]>0.01):
      ch1 = False
      angle = second_wheel_circle1(df.iloc[i,0], df.iloc[i,1], l4, r2)
      df.iloc[i,2] = round(l+lp + r2*np.cos(angle), 2)
      df.iloc[i,3] = round(h-hp + r2*np.sin(angle), 2)
    elif(y2checkpoint3 - df.iloc[i-1,3]>0.01):
      ch2 = False
      df.iloc[i,2] = l+lp+r2
      df.iloc[i,3] = round(df.iloc[i,1] - np.sqrt(np.abs(l4**2 - (df.iloc[i,2] - df.iloc[i,0])**2)), 2)
    elif(y2checkpoint4 - df.iloc[i-1,3]>0.01):
      ch3 = False
      angle = second_wheel_circle2(df.iloc[i,0], df.iloc[i,1], l4, r2)
      df.iloc[i,2] = round(l+lp + r2*np.cos(angle), 2)
      df.iloc[i,3] = round(h + r2*np.sin(angle), 2)
    elif(df.iloc[i-1,2] - x2checkpoint1>0.01):
      df.iloc[i,3] = h+r2
      df.iloc[i,2] = round(df.iloc[i,0] + np.sqrt(np.abs(l4**2 - (df.iloc[i,3] - df.iloc[i,1])**2)), 2)
    else:
      ch4=False
    i=i+1

  checkpoint2 = True
  i = k
  while(checkpoint2):
    if(df.iloc[i-1,4]-l-r3>0.5):

      theeta = slope(df.iloc[i,0], df.iloc[i,1], df.iloc[i,2], df.iloc[i,3])
      if(theeta >= np.pi/2):
        theeta = np.pi - theeta
        if(np.abs(alpha1 - theeta)<0.009):
          df.iloc[i,6] = df.iloc[i,0] + l1
          df.iloc[i,7] = df.iloc[i,1]
        elif(alpha1 - theeta>0):
          df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 - theeta), 2)
          df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 - theeta), 2)
        else:
          df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(theeta - alpha1), 2)
          df.iloc[i,7] = round(df.iloc[i,1] - l1*np.sin(theeta - alpha1), 2)
      else:
        df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 + theeta), 2)
        df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 + theeta), 2)

      df.iloc[i,5] = r3
      df.iloc[i,4] = round(np.sqrt(l34**2 - (df.iloc[i,5] - df.iloc[i,7])**2) + df.iloc[i,6], 2)

      gamma = slope(df.iloc[i,6], df.iloc[i,7], df.iloc[i,4], df.iloc[i,5])
      if(gamma>=np.pi/2):
        gamma = np.pi - gamma
        if(np.abs((gamma+alpha3) - np.pi/2)<0.009):
          df.iloc[i,8] = df.iloc[i,4]
          df.iloc[i,9] = df.iloc[i,5]+l7
        elif(gamma+alpha3)<np.pi/2:
          df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - gamma - alpha3), 2)
          df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - gamma - alpha3), 2)
        else:
          df.iloc[i,8] = round(df.iloc[i,4] + l7*np.sin(alpha3 + gamma - np.pi/2), 2)
          df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(alpha3 + gamma - np.pi/2), 2)
      else:
        df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - alpha3 + gamma), 2)
        df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - alpha3 + gamma), 2)

      beta = slope(df.iloc[i,8], df.iloc[i,9], df.iloc[i,6], df.iloc[i,7])
      df.iloc[i,10] = round(df.iloc[i,6] - l6*np.sin(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,6] + l6*np.sin(np.pi - beta), 2)
      df.iloc[i,11] = round(df.iloc[i,7] + l6*np.cos(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,7] + l6*np.cos(np.pi - beta), 2)

      i = i+1
    else:
      checkpoint2 = False

  row.loc['Y2'] = gamma_function(df.iloc[i-1, 2], df.iloc[i-1,3])
  row.loc['a2'] = slope(df.iloc[i-1, 2], df.iloc[i-1,3], df.iloc[i-1, 6], df.iloc[i-1,7])
  row.loc['a3'] = slope(df.iloc[i-1, 4], df.iloc[i-1,5], df.iloc[i-1, 6], df.iloc[i-1,7])
  row.loc['by'] = df.iloc[i-1, 7] - h
  row.loc['bx'] = l+lp - df.iloc[i-1, 6]
  row.loc['ADC'] = distances_check(df.iloc[i-1], row)

  k = i

  for i in range(k,df.shape[0]):
    theeta = slope(df.iloc[i,0], df.iloc[i,1], df.iloc[i,2], df.iloc[i,3])
    if(theeta >= np.pi/2):
      theeta = np.pi - theeta
      if(np.abs(alpha1 - theeta)<0.009):
        df.iloc[i,6] = df.iloc[i,0] + l1
        df.iloc[i,7] = df.iloc[i,1]
      elif(alpha1 - theeta>0):
        df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 - theeta), 2)
        df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 - theeta), 2)
      else:
        df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(theeta - alpha1), 2)
        df.iloc[i,7] = round(df.iloc[i,1] - l1*np.sin(theeta - alpha1), 2)
    else:
      df.iloc[i,6] = round(df.iloc[i,0] + l1*np.cos(alpha1 + theeta), 2)
      df.iloc[i,7] = round(df.iloc[i,1] + l1*np.sin(alpha1 + theeta), 2)

  ch1 = True
  ch2 = True
  ch3 = True
  ch4 = True
  y3checkpoint1 = round(h-hp - np.sqrt(np.abs(r3**2 - (lp-r3)**2)), 2)
  y3checkpoint2 = h-hp
  y3checkpoint3 = h
  y3checkpoint4 = h+r3
  x3checkpoint1 = round(df.iloc[-1,6] + np.sqrt(l34**2 - (df.iloc[-1,7]-r3)**2), 2)
  maxi = df.shape[0]
  i = k
  while(ch1!=False or ch2!=False or ch3!=False or ch4!=False) and i<maxi:
    if(y3checkpoint1-df.iloc[i-1,5]>0.01):
      df.iloc[i,4] = l+r3
      df.iloc[i,5] = round(df.iloc[i,7] - np.sqrt(np.abs(l34**2 - (df.iloc[i,6] - df.iloc[i,4])**2)), 2)
    elif(y3checkpoint2 - df.iloc[i-1,5]>0.01):
      ch1 = False
      angle = third_wheel_circle1(df.iloc[i,6], df.iloc[i,7], l34, r3)
      df.iloc[i,4] = round(l+lp + r3*np.cos(angle), 2)
      df.iloc[i,5] = round(h-hp + r3*np.sin(angle), 2)
    elif(y3checkpoint3 - df.iloc[i-1,5]>0.01):
      ch2 = False
      df.iloc[i,4] = l+lp+r2
      df.iloc[i,5] = round(df.iloc[i,7] - np.sqrt(np.abs(l34**2 - (df.iloc[i,6] - df.iloc[i,4])**2)), 2)
    elif(y3checkpoint4 - df.iloc[i-1,5]>0.01):
      ch3 = False
      angle = third_wheel_circle2(df.iloc[i,6], df.iloc[i,7], l34, r3)
      df.iloc[i,4] = round(l+lp + r3*np.cos(angle), 2)
      df.iloc[i,5] = round(h + r3*np.sin(angle), 2)
    elif(df.iloc[i-1,4] - x3checkpoint1>0.01):
      df.iloc[i,5] = h+r2
      df.iloc[i,4] = round(df.iloc[i,6] + np.sqrt(np.abs(l34**2 - (df.iloc[i,5] - df.iloc[i,7])**2)), 2)
    else:
      ch4=False
    i=i+1

  for i in range(k, df.shape[0]):
    gamma = slope(df.iloc[i,6], df.iloc[i,7], df.iloc[i,4], df.iloc[i,5])
    if(gamma>=np.pi/2):
      gamma = np.pi - gamma
      if(np.abs((gamma+alpha3) - np.pi/2)<0.009):
        df.iloc[i,8] = df.iloc[i,4]
        df.iloc[i,9] = df.iloc[i,5]+l7
      elif(gamma+alpha3)<np.pi/2:
        df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - gamma - alpha3), 2)
        df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - gamma - alpha3), 2)
      else:
        df.iloc[i,8] = round(df.iloc[i,4] + l7*np.sin(alpha3 + gamma - np.pi/2), 2)
        df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(alpha3 + gamma - np.pi/2), 2)
    else:
      df.iloc[i,8] = round(df.iloc[i,4] - l7*np.sin(np.pi/2 - alpha3 + gamma), 2)
      df.iloc[i,9] = round(df.iloc[i,5] + l7*np.cos(np.pi/2 - alpha3 + gamma), 2)

    beta = slope(df.iloc[i,8], df.iloc[i,9], df.iloc[i,6], df.iloc[i,7])
    df.iloc[i,10] = round(df.iloc[i,6] - l6*np.sin(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,6] + l6*np.sin(np.pi - beta), 2)
    df.iloc[i,11] = round(df.iloc[i,7] + l6*np.cos(beta), 2) if np.degrees(beta)<90 else round(df.iloc[i,7] + l6*np.cos(np.pi - beta), 2)

  row.loc['ADC'] = distances_check(df.iloc[i-1], row)
  return df, row

import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="pandas")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore")

for i in range(main_dataframe.shape[0]):
  print("Iteration {}....".format(i))
  dff, main_dataframe.iloc[i,:] = trajectory_function(main_dataframe.iloc[i,:])
  main_dataframe.at[i, 'DataFrame'] = dff.to_json()
  main_dataframe.at[i, 'A_C'] = assumptions_check(main_dataframe.iloc[i,:])
  main_dataframe.at[i, 'Max height'] = assumptions(main_dataframe.iloc[i,:])
  main_dataframe.at[i, 'S/N ratio'] = SN_ratio(dff, main_dataframe.iloc[i,:])
  print("Iteration{} completed. \n".format(i))

# main_dataframe.to_csv("Output_dataframe", index=False)
main_dataframe

main_dataframe.sort_values(by=['S/N ratio'], axis=0, ascending=False, inplace=False, kind='quicksort', na_position='last', ignore_index=False)

k = 101
df1 = pd.read_json(main_dataframe.at[k, 'DataFrame'])
df = pd.read_json(main_dataframe.at[339, 'DataFrame'])
i = df.shape[0]
plt.figure(figsize=(20, 10))
plt.plot(df.iloc[:i-1,0], df.iloc[:i-1,1], color="red", linewidth=3, label="path")
plt.plot(df.iloc[:i-1,2], df.iloc[:i-1,3], color="blue", linewidth=3, label="trajectory")
plt.plot(df.iloc[:i-1,4], df.iloc[:i-1,5], color="black", linewidth=3, label="trajectory")
plt.plot(df.iloc[:i-1,6], df.iloc[:i-1,7], color="red", linewidth=3, label="trajectory")
plt.plot(df.iloc[:i-1,8], df.iloc[:i-1,9], color="orange", linewidth=3, label="trajectory")
plt.plot(df.iloc[:i-1,10], df.iloc[:i-1,11], color="green", linewidth=3, label="trajectory")
plt.plot([l, 660], [0, 0], color='black', linewidth=2, label="ground")
plt.plot([l, l], [0, h-hp], color='black', linewidth=2, label="height")
plt.plot([l, l+lp], [h-hp, h-hp], color='black', linewidth=2, label="width of the protruding part")
plt.plot([l+lp, l+lp], [h-hp, h], color='black', linewidth=2, label="width of the protruding part")
plt.plot([0, l+lp], [h, h], color='black', linewidth=2, label="width")
plt.gca().invert_xaxis()
plt.grid()
plt.show()

i = df.shape[0]
plt.figure(figsize=(20, 10))
plt.xlim((0,750))
plt.ylim((-2,310))
plt.plot(df.iloc[:i-1,0], df.iloc[:i-1,1], color="red", linewidth=3, label="Wheel 1")
plt.plot(df.iloc[:i-1,2], df.iloc[:i-1,3], color="blue", linewidth=3, label="Wheel 2")
plt.plot(df.iloc[:i-1,4], df.iloc[:i-1,5], color="black", linewidth=3, label="Wheel 3")
plt.plot(df.iloc[:i-1,6], df.iloc[:i-1,7], color="yellow", linewidth=3, label="Bogie")
plt.plot(df.iloc[:i-1,8], df.iloc[:i-1,9], color="orange", linewidth=3)
plt.plot(df.iloc[:i-1,10], df.iloc[:i-1,11], color="green", linewidth=3, label="CM")
plt.plot([l, 750], [0, 0], color='black', linewidth=2)
plt.plot([l, l], [0, h-hp], color='black', linewidth=2)
plt.plot([l, l+lp], [h-hp, h-hp], color='black', linewidth=2)
plt.plot([l+lp, l+lp], [h-hp, h], color='black', linewidth=2)
plt.plot([0, l+lp], [h, h], color='black', linewidth=2)
plt.gca().invert_xaxis()
plt.legend()
plt.grid()
plt.show()

plot_SN_curve(df)
plot_SN_curve(df1)

main_dataframe = iteration1.copy()

main_dataframe.iloc[339,:]
df = pd.read_json(main_dataframe.at[339,'DataFrame'])

df

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import pandas as pd

fig = plt.figure(figsize=(20, 10))
ax = plt.axes(xlim=(0, 800), ylim=(-2, 350))
ax.invert_xaxis()

f = 339
l1 = main_dataframe.at[f, 'l1']
l2 = main_dataframe.at[f, 'l2']
l3 = main_dataframe.at[f, 'l3']
l4 = main_dataframe.at[f, 'l4']
l6 = main_dataframe.at[f, 'l6']
l7 = main_dataframe.at[f, 'l7']

r1 = main_dataframe.at[f, 'r1']
r2 = main_dataframe.at[f, 'r2']
r3 = main_dataframe.at[f, 'r3']

ax.plot([l, 800], [0, 0], color='black', linewidth=2, label="ground")
ax.plot([l, l], [0, h - hp], color='black', linewidth=2, label="height")
ax.plot([l, l + lp], [h - hp, h - hp], color='black', linewidth=2, label="width of the protruding part")
ax.plot([l + lp, l + lp], [h - hp, h], color='black', linewidth=2, label="width of the protruding part")
ax.plot([0, l + lp], [h, h], color='black', linewidth=2, label="width")

l1_, = ax.plot([], [], color='black', linewidth=2, label="l1")
l2_, = ax.plot([], [], color='black', linewidth=2, label="l2")
l7_, = ax.plot([], [], color='black', linewidth=2, label="l7")
l3_, = ax.plot([], [], color='black', linewidth=2, label="l3")
l6_, = ax.plot([], [], color='black', linewidth=2, label="l6")

circle1, = ax.plot([], [], color='black', linewidth=2)
circle2, = ax.plot([], [], color='black', linewidth=2)
circle3, = ax.plot([], [], color='black', linewidth=2)

def init():
    l1_.set_data([], [])
    l2_.set_data([], [])
    l7_.set_data([], [])
    l3_.set_data([], [])
    l6_.set_data([], [])
    circle1.set_data([], [])
    circle2.set_data([], [])
    circle3.set_data([], [])
    return l1_, l2_, l7_, l3_, l6_, circle1, circle2, circle3

def animate(i):
    x14 = np.array([df.iloc[i, 0], df.iloc[i, 6]])
    y14 = np.array([df.iloc[i, 1], df.iloc[i, 7]])

    x24 = np.array([df.iloc[i, 2], df.iloc[i, 6]])
    y24 = np.array([df.iloc[i, 3], df.iloc[i, 7]])

    x35 = np.array([df.iloc[i, 4], df.iloc[i, 8]])
    y35 = np.array([df.iloc[i, 5], df.iloc[i, 9]])

    x45 = np.array([df.iloc[i, 6], df.iloc[i, 8]])
    y45 = np.array([df.iloc[i, 7], df.iloc[i, 9]])

    x46 = np.array([df.iloc[i, 6], df.iloc[i, 10]])
    y46 = np.array([df.iloc[i, 7], df.iloc[i, 11]])

    circle_angle = np.linspace(0, 2 * np.pi, 100)
    x1c = df.iloc[i, 0] + r1 * np.cos(circle_angle)
    y1c = df.iloc[i, 1] + r1 * np.sin(circle_angle)

    x2c = df.iloc[i, 2] + r2 * np.cos(circle_angle)
    y2c = df.iloc[i, 3] + r2 * np.sin(circle_angle)

    x3c = df.iloc[i, 4] + r3 * np.cos(circle_angle)
    y3c = df.iloc[i, 5] + r3 * np.sin(circle_angle)

    l1_.set_data(x14, y14)
    l2_.set_data(x24, y24)
    l7_.set_data(x35, y35)
    l3_.set_data(x45, y45)
    l6_.set_data(x46, y46)

    circle1.set_data(x1c, y1c)
    circle2.set_data(x2c, y2c)
    circle3.set_data(x3c, y3c)

    return l1_, l2_, l7_, l3_, l6_, circle1, circle2, circle3

anim = animation.FuncAnimation(
    fig,
    animate,
    init_func=init,
    frames=df.shape[0],
    interval=20,
    blit=True,
    repeat=False
)

writer = animation.FFMpegWriter(
    fps=30,
    metadata=dict(artist='Me'),
    bitrate=5000,
    codec='h264',
    extra_args=[
        '-preset', 'slow',
        '-profile:v', 'high',
        '-pix_fmt', 'yuv420p'
    ]
)

print("Saving animation...")
anim.save('final_robot_animation.mp4', writer=writer)
print("Animation saved successfully!")

plt.show()

main_dataframe_sorted = iteration1.sort_values(by=['S/N ratio'], axis=0, ascending=True, inplace=False, kind='quicksort', na_position='last', ignore_index=False)
main_dataframe_sorted.reset_index(inplace = True)
# df = pd.read_json(main_dataframe.at[0, 'DataFrame'])

main_dataframe_sorted

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import pandas as pd
from scipy.integrate import simps

# Assuming 'df' is the DataFrame used for SN data
# Replace 'main_dataframe' with the correct DataFrame object for SN curve data
data = pd.read_json(main_dataframe_sorted.at[0, 'DataFrame'])


# Define the SN curve plotting logic inside the animation
def plot_SN_curve(data, i):
    # Extract x_curve and y_curve dynamically for each frame
    y_curve = np.array(data.iloc[:i, 11])
    x_curve = np.array(data.iloc[:i, 10])

    # Assuming variables like 'l', 'lp', 'h', etc., are predefined
    m, _ = line_equation((l + lp, 2 * h), (2 * (l + lp), h))
    c = y_curve[0] - m * x_curve[0]
    y_line = m * x_curve + c

    area_curve = simps(y_curve, x_curve)
    area_line = simps(y_line, x_curve)
    area_between = np.abs(area_curve - area_line)

    ax.clear()  # Clear the plot for each frame
    ax.plot(x_curve, y_curve, label='Curve')
    ax.plot(x_curve, y_line, label='Line', linestyle='--')
    ax.fill_between(
        x_curve, y_curve, y_line,
        where=(y_curve > y_line),
        color='lightgreen', alpha=0.5
    )
    ax.fill_between(
        x_curve, y_curve, y_line,
        where=(y_curve < y_line),
        color='lightcoral', alpha=0.5
    )
    ax.invert_xaxis()
    ax.legend()
    ax.set_title(f"Frame {i}: Area between curve and line: {area_between:.2f}")
    ax.set_xlabel("Stress (MPa)")
    ax.set_ylabel("Cycles to Failure")

# Animation logic
fig, ax = plt.subplots(figsize=(10, 6))

def animate(i):
    plot_SN_curve(data, i)  # Call plot_SN_curve for each frame

anim = animation.FuncAnimation(
    fig,
    animate,
    frames=data.shape[0],  # Number of rows in the DataFrame
    interval=100,          # Time interval between frames (ms)
    blit=False,            # Disable blit for full re-draw
    repeat=False
)

# Save the animation
writer = animation.FFMpegWriter(
    fps=30,
    metadata=dict(artist='Me'),
    bitrate=5000,
    codec='h264',
    extra_args=[
        '-preset', 'slow',
        '-profile:v', 'high',
        '-pix_fmt', 'yuv420p'
    ]
)

print("Saving animation...")
anim.save('SN_curve_animation.mp4', writer=writer)
print("Animation saved successfully!")

plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.integrate import simps

# Function to compute the line equation
def line_equation(p1, p2):
    m = (p2[1] - p1[1]) / (p2[0] - p1[0])
    c = p1[1] - m * p1[0]
    return m, c

# Function to plot the S-N curve
def plot_SN_curve(ax, data, l, lp, h):
    y_curve = np.array(data.iloc[:, 11])
    x_curve = np.array(data.iloc[:, 10])

    # Line equation
    m, _ = line_equation((l + lp, 2 * h), (2 * (l + lp), h))
    c = y_curve[0] - m * x_curve[0]
    y_line = m * x_curve + c

    # Calculate area between the curve and the line
    area_curve = simps(y_curve, x_curve)
    area_line = simps(y_line, x_curve)
    area_between = np.abs(area_curve - area_line)

    # Clear previous frame
    ax.clear()

    # Plot the curve and line
    ax.plot(x_curve, y_curve, label='Curve', color='blue')
    ax.plot(x_curve, y_line, label='Line', linestyle='--', color='orange')

    # Fill between
    ax.fill_between(x_curve, y_curve, y_line, where=(y_curve > y_line), color='lightgreen', alpha=0.5)
    ax.fill_between(x_curve, y_curve, y_line, where=(y_curve < y_line), color='lightcoral', alpha=0.5)

    ax.invert_xaxis()
    ax.legend()
    ax.set_title(f"Area between Curve and Line: {area_between:.2f}")

# Animation setup
def animate(i):
    data = pd.read_json(main_dataframe_sorted.at[i,'DataFrame'])  # Extract the DataFrame for the current row
    plot_SN_curve(ax, data, l, lp, h)
    return ax,

# Initialize the plot
fig, ax = plt.subplots(figsize=(10, 6))

# Create the animation
anim = FuncAnimation(
    fig,
    animate,
    frames=len(main_dataframe_sorted),
    interval=500,  # Adjust frame duration in milliseconds
    blit=False
)

# Save the animation
anim.save('SN_curve_animation.mp4', writer='ffmpeg', fps=5)
plt.show()

iteration1 = pd.read_csv("/content/drive/MyDrive/Output_dataframe")
df_iteration1 = pd.read_json(iteration1.at[339, 'DataFrame'])
iteration1.iloc[339,:]



df_iteration1

l1 = [88.0, 90.0, 92.0, 94.0]
l2 = [78.0, 80.0, 82.0, 84.0]
l3 = [195.0, 200.0, 205.0, 210.0]
l4 = [150.0, 155.0, 160.0, 165.0]
l6 = [80.0, 90.0]

permutations = list(product(l1, l2, l3, l4, l6))
names = ['l1', 'l2', 'l3', 'l4', 'l6']
main_df2 = create_df(permutations, names)

print(f"DataFrame shape: {main_df2.shape}")
print("\nColumn types:")
print(main_df2.dtypes)

main_df2['r1'] = 65
main_df2['r2'] = 55
main_df2['r3'] = 55
main_df2['l5'] = 50

main_df2

main_dataframe2 = constraints_function(main_df2)
main_dataframe2 = main_dataframe2.reset_index(drop=True)
main_dataframe2

import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="pandas")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore")

for i in range(main_dataframe2.shape[0]):
  print("Iteration {}....".format(i))
  dff, main_dataframe2.iloc[i,:] = trajectory_function(main_dataframe2.iloc[i,:])
  main_dataframe2.at[i, 'DataFrame'] = dff.to_json()
  main_dataframe2.at[i, 'A_C'] = assumptions_check(main_dataframe2.iloc[i,:])
  main_dataframe2.at[i, 'Max height'] = assumptions(main_dataframe2.iloc[i,:])
  main_dataframe2.at[i, 'S/N ratio'] = SN_ratio(dff, main_dataframe2.iloc[i,:])
  print("Iteration{} completed. \n".format(i))

main_dataframe2.sort_values(by=['S/N ratio'], axis=0, ascending=False, inplace=False, kind='quicksort', na_position='last', ignore_index=False)

plot_SN_curve(df)
plot_SN_curve(df3)